# statistics functions

#' Average future lifetime
#'
#' Calculates the average future life time and its standard deviation
#' given initial state and age of an individual by simulating life time paths.
#' Function needs to be provided either a list of transition probability matrices,
#' or a simulated lifetime path from \code{health3_simulate_paths}. If both are provided,
#' then the function will use the simulated path provided.
#' NOTE: USE \code{health3_aflF} for frailty model.
#'
#' @param init_age
#' integer between 65 and 110 denoting initial age of individual. This needs to be same
#' initial age used in generation of `trans_probs` or `simulated_path`
#'
#' @param init_state
#' 0 for healthy, 1 for disabled
#'
#' @param trans_probs
#' a list of transition probability matrices, preferably generated from
#' \code{get_trans_probs}.
#'
#' @param simulated_path
#' a matrix of lifetime paths simulations, generated by \code{health3_simulate_paths}.
#'
#' @return
#' numeric output for average and standard deviation of future lifetime
#'
#' @export
#'
#' @examples example
health3_afl <- function(init_age, init_state, trans_probs = NULL, simulated_path = NULL) {
  # screening for errors
  if (init_state != 0 & init_state != 1) {
    stop('invalid state, use 0 for healthy and 1 for disabled')
  }

  if (init_age<65 | init_age>110) {
    stop('invalid age')
  }

  if (as.integer(init_age) != init_age) {
    stop('initial age must be an integer')
  }

  if (is.null(trans_probs) & is.null(simulated_path)) {
    stop('no transition probability matrices or simulated paths were provided')
  }

  if (!is.null(simulated_path) & !is.null(trans_probs)) {
    if (ncol(simulated_path) != 111-init_age +1) {
      stop('initial age does not correspond with size of simulated path')
    }

    # simulate path
    SP <- simulated_path
  } else if (is.null(trans_probs)) {
    if (ncol(simulated_path) != 111-init_age +1) {
      stop('initial age does not correspond with size of simulated path')
    }

    SP <- simulated_path
  } else {
    if (length(trans_probs) != 111-init_age) {
      stop('initial age does not correspond with number of transition probability matrices')
    }

    SP <- health3_simulate_paths(trans_probs, init_age, init_state, 50000)
  }
  # count time at death
  future_lifetimes <- rep(0, nrow(SP))
  for (i in 1:nrow(SP)) {
    row_val = SP[i, ]
    future_lifetimes[i] <- which(row_val == -1)[1]-1-0.5 # assume transition happens mid year
  }
  return(list('mean' = mean(future_lifetimes), 's.dev' = stats::sd(future_lifetimes)))
}



#' Average future lifetime (Frailty Model)
#'
#' Performs the same function as the \code{health3_afl}, but simulates a number of
#' unique latent factor paths to make probabilities stochastic.
#' NOTE: USE \code{health3_afl} for static and trend models.
#'
#' @param init_age
#' integer between 65 and 110 indicating initial age of individual
#'
#' @param init_state
#' 0 for healthy, 1 for disabled
#'
#' @param female
#' 0 for male, 1 for female
#'
#' @param year
#' integer indicating current year
#'
#' @param param_file
#' string for file path of parameter file OR a tibble/dataframe of parameters
#'
#' @param n
#' integer denoting number of unique latent factor simulations
#'
#'
#' @return
#' numeric output for expected future lifetime and standard deviation of future lifetime
#'
#' @export
#'
#' @examples example
health3_aflF <- function(init_age, init_state, female, year, param_file, n = 1000) {
  # flagging errors
  if (init_age < 65 | init_age > 110) {
    stop('invalid age')
  }

  if (as.integer(init_age) != init_age) {
    stop('initial age must be an integer')
  }

  if (init_state != 0 & init_state != 1) {
    stop('invalid state, use 0 for healthy and 1 for disabled')
  }

  if (female != 0 & female != 1) {
    stop('invalid gender, use 0 for male and 1 for female')
  }

  if (n != as.integer(n)) {
    stop('non integer value of n')
  }

  if (n <= 0) {
    stop('n must be positive')
  }

  future_lifetimes <- rep(0, n*10000)
  for (x in 1:n) {
    # simulate new frailty path for each iteration
    TP <- health3_get_trans_probs('F', param_file, init_age, female, year)
    SP <- health3_simulate_paths(TP, init_age, init_state, cohort=10000)
    for (i in 1:nrow(SP)) {
      row_val <- SP[i, ]
      future_lifetimes[(x-1)*10000+i] <- which(row_val == -1)[1]-1-0.5
    }
  }
  return(list('mean' = mean(future_lifetimes), 's.dev' = stats::sd(future_lifetimes)))
}


#' Healthy Future lifetime
#'
#' Calculates the expected future lifetime spent and its standard deviation
#' in the healthy state. Function uses either transition probability matrices, or
#' a simulated lifetime paths. If both are provided, it will use the simulated lifetime
#' provided.
#' NOTE: USE \code{health3_hflF} FOR FRAILTY MODEL.
#'
#' @param init_age
#' integer between 65 and 110 denoting initial age of individual
#'
#' @param init_state
#' 0 for healthy, 1 for disabled
#'
#' @param trans_probs
#' list of transition probability matrices; ideally generated from
#' \code{health3_get_trans_probs}.
#'
#' @param simulated_path
#' a matrix of lifetime paths simulations, generated by \code{health3_simulate_paths}.
#'
#' @return
#' Numeric output of expected time and standard deviation of time spent in healthy state.
#'
#' @export
#'
#' @examples example
health3_hfl <- function(init_age, init_state, trans_probs = NULL, simulated_path = NULL) {
  # screening for errors
  if (init_state != 0 & init_state != 1) {
    stop('invalid state, use 0 for healthy and 1 for disabled')
  }

  if (init_age<65 | init_age>110) {
    stop('invalid age')
  }

  if (as.integer(init_age) != init_age) {
    stop('initial age must be an integer')
  }

  if (is.null(trans_probs) & is.null(simulated_path)) {
    stop('no transition probability matrices or simulated paths were provided')
  }

  # generate simulation path, or just take it from input
  if (!is.null(simulated_path) & !is.null(trans_probs)) {
    if (ncol(simulated_path) != 111-init_age +1) {
      stop('initial age does not correspond with size of simulated path')
    }

    SP <- simulated_path
  } else if (is.null(trans_probs)) {
    if (ncol(simulated_path) != 111-init_age +1) {
      stop('initial age does not correspond with size of simulated path')
    }

    SP <- simulated_path
  } else {
    if (length(trans_probs) != 111-init_age) {
      stop('initial age does not correspond with number of transition probability matrices')
    }

    # simulate path
    SP <- health3_simulate_paths(trans_probs, init_age, init_state, 50000)
  }
  healthy_lifetimes <- rep(0, nrow(SP))
  for (i in 1:nrow(SP)) {
    row_val <- SP[i,]
    if (init_state == 0) {
      healthy_lifetimes[i] <- sum(row_val == 0) - 0.5 # transition happens in middle of period
    } else {
      healthy_lifetimes[i] <- sum(row_val == 0)
    }
  }
  return(list('mean' = mean(healthy_lifetimes), 's.dev' = stats::sd(healthy_lifetimes)))
}

#' Heatlhy Future Lifetime (Frailty Model)
#'
#' Performs the same function as \code{health3_hfl}, but simulates unique latent factor
#' paths in the process.
#' NOTE: USE \code{health3_hfl} for static and trend models.
#'
#' @param init_age
#' integer between 65 and 110 denoting initial age of individual
#'
#' @param init_state
#' 0 for healthy, 1 for disabled
#'
#' @param female
#' 0 for male, 1 for female
#'
#' @param year
#' integer denoting current year
#'
#' @param param_file
#' string for file path of parameter file OR a tibble/dataframe of parameters
#'
#' @param n
#' integer denoting number of simulations
#'
#' @return
#' Numeric output denoting the average time spent in healthy state and its
#' standard deviation.
#'
#' @export
#'
#' @examples example
health3_hflF <- function(init_age, init_state, female, year, param_file, n = 1000) {
  # flagging errors
  if (init_age < 65 | init_age > 110) {
    stop('invalid age')
  }

  if (as.integer(init_age) != init_age) {
    stop('initial age must be an integer')
  }

  if (init_state != 0 & init_state != 1) {
    stop('invalid state, use 0 for healthy and 1 for disabled')
  }

  if (female != 0 & female != 1) {
    stop('invalid gender, use 0 for male and 1 for female')
  }

  if (n != as.integer(n)) {
    stop('non integer value of n')
  }

  if (n <= 0) {
    stop('n must be positive')
  }

  healthy_lifetimes <- rep(0, n*10000)
  for (x in 1:n) {
    TP <- health3_get_trans_probs('F', param_file, init_age, female, year)
    SP <- health3_simulate_paths(TP, init_age, init_state, cohort=10000)
    for (i in 1:nrow(SP)) {
      row_val <- SP[i,]
      if (init_state == 0) {
        healthy_lifetimes[(x-1)*10000+i] <- sum(row_val == 0) - 0.5
      } else {
        healthy_lifetimes[(x-1)*10000+i] <- sum(row_val == 0)
      }
    }
  }
  return(list('mean' = mean(healthy_lifetimes), 's.dev' = stats::sd(healthy_lifetimes)))
}



#' Disabled Future Lifetime
#'
#' Calculates the average future lifetime spent in disabled state and the standard
#' deviation by simulating life time paths given a list of transition probability
#' matrices. Function uses either list of transition probability matrices, or a
#' simulated path. If both are provided, then the simulated path will be used.
#' NOTE: THIS FUNCTION SHOULD ONLY BE USED WITH STATIC AND TREND MODELS. USE
#' \code{health3_dflF} FOR FRAILTY MODEL.
#'
#' @param init_age
#' integer between 65 and 110 denoting age of individual
#'
#' @param init_state
#' 0 for healthy, 1 for disabled
#'
#' @param trans_probs
#' a list of transition probability matrices, preferably generated from
#' \code{health3_get_trans_probs}.
#'
#' @param simulated_path
#' a matrix of lifetime paths simulations, generated by \code{health3_simulate_paths}.
#'
#' @return
#' numeric output for average future lifetime in disabled state and its standard
#' deviation.
#'
#' @export
#'
#' @examples example
health3_dfl <- function(init_age, init_state, trans_probs = NULL, simulated_path = NULL) {
  # screening for errors
  if (init_state != 0 & init_state != 1) {
    stop('invalid state, use 0 for healthy and 1 for disabled')
  }

  if (init_age<65 | init_age>110) {
    stop('invalid age')
  }

  if (as.integer(init_age) != init_age) {
    stop('initial age must be an integer')
  }

  if (is.null(trans_probs) & is.null(simulated_path)) {
    stop('no transition probability matrices or simulated paths were provided')
  }

  # simulate path and count disabled time
  if (!is.null(simulated_path) & !is.null(trans_probs)) {
    if (ncol(simulated_path) != 111-init_age +1) {
      stop('initial age does not correspond with size of simulated path')
    }

    SP <- simulated_path
  } else if (is.null(trans_probs)) {
    if (ncol(simulated_path) != 111-init_age +1) {
      stop('initial age does not correspond with size of simulated path')
    }

    SP <- simulated_path
  } else {
    if (length(trans_probs) != 111-init_age) {
      stop('initial age does not correspond with number of transition probability matrices')
    }

    # simulate path
    SP <- health3_simulate_paths(trans_probs, init_age, init_state, 50000)
  }

  disabled_lifetime <- rep(0, nrow(SP))
  for (i in 1:nrow(SP)) {
    row_val <- SP[i, ]
    if (init_state == 1) {
      disabled_lifetime[i] <- sum(row_val == 1) - 0.5 # transition happens mid year
    } else {
      disabled_lifetime[i] <- sum(row_val == 1)
    }
  }
  return(list('mean' = mean(disabled_lifetime), 's.dev' = stats::sd(disabled_lifetime)))
}


#' Disabled Future Lifetime (frailty model)
#'
#' Performs the same function as \code{health3_dfl}, but it requires inputs
#' to simulate latent factor in the frailty model. This allows it to simulate the
#' the randomness from the frailty factor into the calculation as well.
#' NOTE: THIS FUNCTION SHOULD ONLY BE USED WITH THE FRAILTY MODEL. USE \code{health3_dfl}
#' FOR STATIC AND TREND MODEL.
#'
#' @param init_age
#' integer between 65 and 110 denoting initial age of individual
#' @param init_state
#' 0 for healthy and 1 for disabled
#' @param female
#' 0 for non female, 1 for female
#' @param year
#' integer for current year
#' @param param_file
#' string for file path of parameter file OR a tibble/dataframe of parameters
#' @param n
#' integer representing number of unique latent factors to simulate
#'
#' @return
#' numeric output for average time spent and standard deviation of time in disabled state
#'
#' @export
#'
#' @examples example
health3_dflF <- function(init_age, init_state, female, year, param_file, n = 1000) {
  # flagging errors
  if (init_age < 65 | init_age > 110) {
    stop('invalid age')
  }

  if (as.integer(init_age) != init_age) {
    stop('initial age must be an integer')
  }

  if (init_state != 0 & init_state != 1) {
    stop('invalid state, use 0 for healthy and 1 for disabled')
  }

  if (female != 0 & female != 1) {
    stop('invalid gender, use 0 for male and 1 for female')
  }

  if (n != as.integer(n)) {
    stop('non integer value of n')
  }

  if (n <= 0) {
    stop('n must be positive')
  }

  disabled_lifetime <- rep(0, n*10000)
  # simulate n unique latent factors
  for (x in 1:n) {
    TP <- health3_get_trans_probs('F', param_file, init_age, female, year)
    SP <- health3_simulate_paths(TP, init_age, init_state, cohort=10000)
    for (i in 1:nrow(SP)) {
      row_val <- SP[i,]
      if (init_state == 1) {
        disabled_lifetime[(x-1)*10000+i] <- sum(row_val == 1) - 0.5
      } else {
        disabled_lifetime[(x-1)*10000+i] <- sum(row_val == 1)
      }
    }
  }
  return(list('mean' = mean(disabled_lifetime), 's.dev' = stats::sd(disabled_lifetime)))
}


#' Time until onset of disability (conditional on being disabled)
#'
#' Uses simulation to produce an average time until a healthy individual becomes disabled
#' during their life time. Note that this is conditional on the individual becoming disabled,
#' so it doesn't factor in life simulations where the individual is always healthy. Function
#' requires either list of transition probability matrices, or simulated lifetime paths.
#' If both are given, then the simulated lifetime paths is used.
#' NOTE: USE \code{health3_time_to_disabledF} for frailty model.
#'
#'
#' @param init_age
#' integer between 65 and 110 denoting initial age of individual
#'
#' @param trans_probs
#' a list of transition probability matrices, preferably generated from
#' \code{health3_get_trans_probs}.
#'
#' @param simulated_path
#' a matrix of lifetime paths simulations, generated by \code{health3_simulate_paths}.
#'
#' @return
#' numeric denoting the average time until individual becomes disabled and its
#' standard deviation.
#'
#' @export
#'
#' @examples example
health3_time_to_disabled <- function(init_age, trans_probs = NULL, simulated_path = NULL) {
  # screening for errors
  if (init_age<65 | init_age>110) {
    stop('invalid age')
  }

  if (as.integer(init_age) != init_age) {
    stop('initial age must be an integer')
  }

  if (is.null(trans_probs) & is.null(simulated_path)) {
    stop('no transition probability matrices or simulated paths were provided')
  }

  # simulate path or just use path given
  if (!is.null(simulated_path) & !is.null(trans_probs)) {
    if (ncol(simulated_path) != 111-init_age +1) {
      stop('initial age does not correspond with size of simulated path')
    }

    SP <- simulated_path
  } else if (is.null(trans_probs)) {
    if (ncol(simulated_path) != 111-init_age +1) {
      stop('initial age does not correspond with size of simulated path')
    }

    SP <- simulated_path
  } else {
    if (length(trans_probs) != 111-init_age) {
      stop('initial age does not correspond with number of transition probability matrices')
    }

    # simulate path
    SP <- health3_simulate_paths(trans_probs, init_age, 0, 50000)
  }

  first_time <- rep(0, nrow(SP))
  for (i in 1:nrow(SP)) {
    row_val <- SP[i, ]
    if (1 %in% row_val) {
      first_time[i] <- which(row_val == 1)[1]-1-0.5
    }
  }
  first_time <- first_time[first_time != 0]
  return(list('mean' = mean(first_time), 's.dev' = stats::sd(first_time)))
}



#' Time until onset of disability (Frailty model)
#'
#' Function serves the same purpose as \code{health3_time_to_disabled}, but it is for
#' the frailty model.
#'
#' @param init_age
#' integer between 65 and 110
#'
#' @param female
#' 0 for male, 1 for female
#'
#' @param year
#' integer denoting current year
#'
#' @param param_file
#' string for file path of parameter file OR a tibble/dataframe of parameters
#'
#' @param n
#' integer denoting number of simulations to make
#'
#' @return
#' numeric denoting the average time until individual becomes disabled, and its
#' standard deviation.
#'
#' @export
#'
#' @examples example
health3_time_to_disabledF <- function(init_age, female, year, param_file, n = 1000) {
  # flagging errors
  if (init_age < 65 | init_age > 110) {
    stop('invalid age')
  }

  if (as.integer(init_age) != init_age) {
    stop('initial age must be an integer')
  }

  if (female != 0 & female != 1) {
    stop('invalid gender, use 0 for male and 1 for female')
  }

  if (n != as.integer(n)) {
    stop('non integer value of n')
  }

  if (n <= 0) {
    stop('n must be positive')
  }

  # create n unique latent factor paths
  first_time <- rep(0, n*10000)
  for (x in 1:n) {
    TP <- health3_get_trans_probs('F', param_file, init_age, female, year)
    SP <- health3_simulate_paths(TP, init_age, 0, cohort=10000)
    for (i in nrow(SP)) {
      row_val <- SP[i,]
      if (1 %in% row_val) {
        first_time[(x-1)*10000+i] <- which(row_val == 1)[1]-1-0.5
      }
    }
  }
  first_time <- first_time[first_time != 0]
  return(list('mean' = mean(first_time), 's.dev' = stats::sd(first_time)))
}


#' Survival Statistics
#'
#' Produces statistics including: total expected lifetime, healthy lifetime,
#' disabled lifetime, onset of disability (if initial state is healthy). It uses
#' either transition probability matrices or a simulated paths.
#' NOTE: USE \code{health3_survival_statsF} FOR FRAILTY MODEL.
#'
#' @param init_age
#' integer between 65 and 110 denoting initial age of individual
#' @param init_state
#' 0 for healthy, 1 for disabled
#' @param trans_probs
#' list of transition probability matrices, generated from \code{health3_get_trans_probs}.
#' @param simulated_path
#' matrix containing lifetime path simulations from \code{health3_simulate_paths} function.
#'
#' @return
#' dataframe output containing mean and standard deviation of different statistics
#'
#' @export
#'
#' @examples example
health3_survival_stats <- function(init_age, init_state, trans_probs = NULL, simulated_path = NULL) {
  # screening for errors
  if (init_state != 0 & init_state != 1) {
    stop('invalid state, use 0 for healthy and 1 for disabled')
  }

  if (init_age<65 | init_age>110) {
    stop('invalid age')
  }

  if (as.integer(init_age) != init_age) {
    stop('initial age must be an integer')
  }

  if (is.null(trans_probs) & is.null(simulated_path)) {
    stop('no transition probability matrices or simulated paths were provided')
  }

  # simulate path or just use path given
  if (!is.null(simulated_path) & !is.null(trans_probs)) {
    if (ncol(simulated_path) != 111-init_age +1) {
      stop('initial age does not correspond with size of simulated path')
    }

    SP <- simulated_path
  } else if (is.null(trans_probs)) {
    if (ncol(simulated_path) != 111-init_age +1) {
      stop('initial age does not correspond with size of simulated path')
    }

    SP <- simulated_path
  } else {
    if (length(trans_probs) != 111-init_age) {
      stop('initial age does not correspond with number of transition probability matrices')
    }

    # simulate path
    SP <- health3_simulate_paths(trans_probs, init_age, init_state, 50000)
  }

  # empty vectors to hold row datas
  total_lifetime <- rep(0, nrow(SP))
  healthy_lifetime <- rep(0, nrow(SP))
  disabled_lifetime <- rep(0, nrow(SP))
  first_disabled <- rep(0, nrow(SP))

  for (i in 1:nrow(SP)) {
    # extract relevant data from rows
    row_val <- SP[i, ]
    if (init_state == 0) {
      total_lifetime[i] <- which(row_val == -1)[1] - 1.5
      healthy_lifetime[i] <- sum(row_val == 0) - 0.5
      disabled_lifetime[i] <- sum(row_val == 1)
      first_disabled[i] <- which(row_val == 1)[1] - 1.5
    } else {
      total_lifetime[i] <- which(row_val == -1)[1] - 1.5
      healthy_lifetime[i] <- sum(row_val == 0)
      disabled_lifetime[i] <- sum(row_val == 1) - 0.5
    }
  }
  if (init_state == 0) {
    means <- c(mean(total_lifetime), mean(healthy_lifetime), mean(disabled_lifetime),
              mean(first_disabled, na.rm = TRUE))
    sds <- c(stats::sd(total_lifetime), stats::sd(healthy_lifetime), stats::sd(disabled_lifetime),
            stats::sd(first_disabled, na.rm = TRUE))
    stats_df <- data.frame(
      'stats' = c('total_life', 'healthy_life', 'disabled_life', 'onset_disability'),
      'mean' = means,
      's.dev' = sds
    )
    return(stats_df)
  } else {
    means <- c(mean(total_lifetime), mean(healthy_lifetime), mean(disabled_lifetime))
    sds <- c(stats::sd(total_lifetime), stats::sd(healthy_lifetime), stats::sd(disabled_lifetime))
    stats_df <- data.frame(
      'stats' = c('total_life', 'healthy_life', 'disabled_life'),
      'mean' = means,
      's.dev' = sds
    )
    return(stats_df)
  }
}



#' Survival Statistics (Frailty Model)
#'
#' Produces statistics including: total expected lifetime, healthy lifetime,
#' disabled lifetime, onset of disability (if initial state is healthy). It uses
#' either transition probability matrices or a simulated paths.
#'
#' @param init_age
#' integer between 65 and 110 denoting initial age of individual
#' @param init_state
#' 0 for healthy, 1 for disabled
#' @param female
#' 0 for male, 1 for female
#' @param year
#' integer denoting current year
#' @param param_file
#' string for file path of parameter file OR a tibble/dataframe of parameters
#' @param n
#' integer denoting number of latent factor simulations
#'
#' @return
#' dataframe output containing mean and standard deviation of different statistics
#'
#' @export
#'
#' @examples example
health3_survival_statsF <- function(init_age, init_state, female, year, param_file, n = 1000) {
  # flagging errors
  if (init_age < 65 | init_age > 110) {
    stop('invalid age')
  }

  if (as.integer(init_age) != init_age) {
    stop('initial age must be an integer')
  }

  if (init_state != 0 & init_state != 1) {
    stop('invalid state, use 0 for healthy and 1 for disabled')
  }

  if (female != 0 & female != 1) {
    stop('invalid gender, use 0 for male and 1 for female')
  }

  if (n != as.integer(n)) {
    stop('non integer value of n')
  }

  if (n <= 0) {
    stop('n must be positive')
  }

  # empty vectors to hold row datas
  total_lifetime <- rep(0, n*10000)
  healthy_lifetime <- rep(0, n*10000)
  disabled_lifetime <- rep(0, n*10000)
  first_disabled <- rep(0, n*10000)

  for (x in 1:n) {
    TP <- health3_get_trans_probs('F', param_file, init_age, female, year)
    SP <- health3_simulate_paths(TP, init_age, init_state, cohort=10000)

    for (i in 1:nrow(SP)) {
      row_val <- SP[i,]
      if (init_state == 0) {
        total_lifetime[(x-1)*10000+i] <- which(row_val == -1)[1] - 1.5
        healthy_lifetime[(x-1)*10000+i] <- sum(row_val == 0) - 0.5
        disabled_lifetime[(x-1)*10000+i] <- sum(row_val == 1)
        first_disabled[(x-1)*10000+i] <- which(row_val == 1)[1] - 1.5
      } else {
        total_lifetime[(x-1)*10000+i] <- which(row_val == -1)[1] - 1.5
        healthy_lifetime[(x-1)*10000+i] <- sum(row_val == 0)
        disabled_lifetime[(x-1)*10000+i] <- sum(row_val == 1) - 0.5
      }
    }
  }

  if (init_state == 0) {
    means <- c(mean(total_lifetime), mean(healthy_lifetime), mean(disabled_lifetime),
               mean(first_disabled, na.rm = TRUE))
    sds <- c(stats::sd(total_lifetime), stats::sd(healthy_lifetime), stats::sd(disabled_lifetime),
             stats::sd(first_disabled, na.rm = TRUE))
    stats_df <- data.frame(
      'stats' = c('total_life', 'healthy_life', 'disabled_life', 'onset_disability'),
      'mean' = means,
      's.dev' = sds
    )
    return(stats_df)
  } else {
    means <- c(mean(total_lifetime), mean(healthy_lifetime), mean(disabled_lifetime))
    sds <- c(stats::sd(total_lifetime), stats::sd(healthy_lifetime), stats::sd(disabled_lifetime))
    stats_df <- data.frame(
      'stats' = c('total_life', 'healthy_life', 'disabled_life'),
      'mean' = means,
      's.dev' = sds
    )
    return(stats_df)
  }
}













